# ---
# title:  "STL_model_fit"
# author: "Zach Tefertiller"
# date:   "2025-02-24"
# output: html_document
# zachary.tefertiller@tum.de
# ---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r load libraries and dataset}

library(dplyr)
library(bayesplot)
library(ggplot2)
library(pryr)
library(loo)
library(cmdstanr)
library(posterior)


# initial setup for my own task design, adapt balloon_color in the code and dataset as needed.

dataset <- read.csv('balloon_task_clean_data.csv', header=TRUE, sep=",", stringsAsFactors=FALSE)

# setup dataframe for reversal
df <- dataset %>%
  mutate(color_max = case_when(
    balloon_color == 'y' ~ 32,
    balloon_color == 'o' & trial_number > 91 ~ 128,
    balloon_color == 'o' & trial_number < 91 ~ 8,
    balloon_color == 'b' & trial_number < 91 ~ 128,
    balloon_color == 'b' & trial_number >= 91 ~ 8
  ))
df$opportunity <- df$inflations + (1 - df$popped)
print_df_info <- function(df) {
  df_name <- deparse(substitute(df))
  number_of_participants <- length(unique(df$participant_id))
  number_of_trials <- nrow(df) / number_of_participants
  cat("Dataframe used:", df_name, "\n")
  cat("Number of trials per participant:", number_of_trials, "\n")
  cat("Number of participants with criteria:", number_of_participants, "\n")
  return(list(
    number_of_participants = number_of_participants,
    number_of_trials = number_of_trials
  ))
}

```


```{r summarize questionnaires if included}
# run this if you want to include spq, pdi, and caps in model

# dropping people who lack all questionnaires
df <- df %>%
  filter(!is.na(caps_total) & !is.na(pdi_total))


# summarize questionnaires, z-score, put in other dataframe for when we call
df_questionnaires <- df %>%
  group_by(participant_id) %>%
  summarise(
    spq_total  = first(spq_total_score),
    caps_total = first(caps_total),
    pdi_total  = first(pdi_total),
    pdi_distress  = first(pdi_distress),
    pdi_frequency  = first(pdi_frequency),
    pdi_conviction  = first(pdi_conviction),
    caps_distress = first(caps_distress),
    caps_frequency = first(caps_frequency),
    caps_intrusiveness = first(caps_intrusiveness),
    phq_total = first(phq_total),  
    mdq_total = first(mdq_total),
    ppgm_total = first(ppgm_total),
    ipip_total = first(ipip_total_score)
    
  ) %>%
  mutate(
    spq_z  = as.vector(scale(spq_total, center = TRUE, scale = TRUE)),
    caps_z = as.vector(scale(caps_total, center = TRUE, scale = TRUE)),
    pdi_z  = as.vector(scale(pdi_total, center = TRUE, scale = TRUE))
  )

df <- df %>% 
  left_join(df_questionnaires, by = "participant_id")

questionnaires <- df_questionnaires %>% 
  arrange(participant_id)

sub_ids <- unique(df$participant_id)

for (col in gsub("\\.x$", "", grep("\\.x$", names(df), value = TRUE))) {
  df[[col]] <- coalesce(df[[paste0(col, ".x")]], df[[paste0(col, ".y")]])
}
df <- df %>%
  select(-ends_with(".x"), -ends_with(".y"))


```

```{r load function: stan input data}
# function for assembling the data for STAN model
# questionnaires excluded as model params by default

create_stan_params <- function(df, include_questionnaires = FALSE) {
  nsub <- length(unique(df$participant_id))
  ntrial <- nrow(df) / nsub
  Tsubj <- rep(ntrial, nsub)
  outcome   <- matrix(df$popped, nrow = nsub, ncol = ntrial, byrow = TRUE)
  npumps    <- matrix(df$inflations, nrow = nsub, ncol = ntrial, byrow = TRUE)
  nmax <- matrix(df$color_max, nrow = nsub, ncol = ntrial, byrow = TRUE)
  # think of nmax as "how far could you possibly pump if the balloon didn't pop earlier?"
  # it is the upper bound of the uniform distribution that burst points were sampled from
  opportunity <- npumps + (1 - outcome)
  maxpump <- max(nmax)
  
  # map balloon color to numbers for stan
  # blue = 1
  # orange = 2
  # yellow = 3
  df$balloon_color_num <- match(df$balloon_color, c("b", "o", "y"))
  balloon_color <- matrix(df$balloon_color_num, nrow = nsub, ncol = ntrial, byrow = TRUE)
  
  #maxpump is for the size of the opportunity array for stan indexing
  d <- array(NA, dim = c(nsub, ntrial, maxpump))
  for (i in 1:nsub) {
    for (j in 1:ntrial) {
      pumps <- npumps[i, j]
      out   <- outcome[i, j]
      if (pumps > 0) {
        d[i, j, 1:pumps] <- rep(1, pumps)
      }
      if (pumps < maxpump && out == 0) {
        d[i, j, pumps + 1] <- 0
      }
    }
  }
  
  participant_ids <- df$participant_id[!duplicated(df$participant_id)]
  
  #going back over NA values with 75 as placeholder because stan doesnt like NA
  d[is.na(d)] <- 75
  
  stan_data <- list(
    nsub = nsub,
    ntrial = ntrial,
    Tsubj = Tsubj,
    outcome = outcome,
    npumps = npumps,
    nmax = nmax,
    opportunity = opportunity,
    maxpump = maxpump,
    d = d,
    balloon_color = balloon_color,
    sub_ids = sub_ids  # including participant ids for tracking in stan summary
  )
    stan_data$sub_ids <- as.integer(factor(df$participant_id[!duplicated(df$participant_id)], 
                                       levels = participant_ids))
    stan_data$subj_idx <- 1:stan_data$nsub

  if (include_questionnaires) {
      questionnaires <- data.frame(
        participant_id = df$participant_id[!duplicated(df$participant_id)],
        spq_z = df$spq_z[!duplicated(df$participant_id)],
        caps_z = df$caps_z[!duplicated(df$participant_id)],
        pdi_z = df$pdi_z[!duplicated(df$participant_id)]
      )
      stan_data$spq  <- questionnaires$spq_z    # spq paired w/ participant_ids
      stan_data$caps <- questionnaires$caps_z   # caps 
      stan_data$pdi  <- questionnaires$pdi_z    # pdi
  }
  
  return(stan_data)
}
```


```{r loading stan parameters}
stan_data <- create_stan_params(df)
```



```{r}
# ============================================================
# 0.  PACKAGES  ----------------------------------------------
# (install afex once if you haven't: install.packages("afex", dep = TRUE))
# ======================================================================
# 0.  PACKAGES  --------------------------------------------------------
# (install once if missing: install.packages("afex", dependencies = TRUE))
library(dplyr)
library(tidyr)
library(afex)            # aov_4()
library(posterior)

# ======================================================================
# 1.  HIGH- vs LOW-SPQ SAMPLE  ----------------------------------------
n_group <- 22
spq_rank <- df_questionnaires |> arrange(desc(spq_z))

high_ids <- spq_rank$participant_id[1:n_group]
low_ids  <- spq_rank$participant_id[(nrow(spq_rank) - n_group + 1):nrow(spq_rank)]

df_groups <- df |>
  filter(participant_id %in% c(high_ids, low_ids)) |>
  mutate(group = if_else(participant_id %in% high_ids, "HighSPQ", "LowSPQ"))

# ======================================================================
# 2.  BUILD THE TWO BLOCK DATASETS  -----------------------------------
#    • BlueBlock  = first 30 blue balloons
#    • OrangeBlock = last 30 orange balloons
blue_block <- df_groups |>
  filter(balloon_color == "b") |>
  group_by(participant_id) |>
  arrange(trial_number, .by_group = TRUE) |>
  slice_head(n = 30) |>
  ungroup()

orange_block <- df_groups |>
  filter(balloon_color == "o") |>
  group_by(participant_id) |>
  arrange(trial_number, .by_group = TRUE) |>
  slice_tail(n = 30) |>
  ungroup()

# ======================================================================
# 3.  FIT STAN ON EACH BLOCK  -----------------------------------------
get_vwin_block <- function(data_block, block_label) {
  fit <- cmd_stan_fit(create_stan_params(data_block),
                      paste0(tolower(block_label), "_stanfit"))
  
  draws <- fit$draws(variables = "vwin", format = "draws_df") |>
           summarise(across(everything(), mean)) |>
           pivot_longer(everything(),
                        names_to  = "param",
                        values_to = "vwin") |>
           mutate(sub_idx = as.integer(sub("\\D+", "", param))) |>
           select(sub_idx, vwin)
  
  tibble(
    participant_id = sort(unique(data_block$participant_id))[draws$sub_idx],
    vwin           = draws$vwin,
    block          = block_label
  )
}

vwin_blue   <- get_vwin_block(blue_block,   "BlueBlock")
vwin_orange <- get_vwin_block(orange_block, "OrangeBlock")
vwin_tbl    <- bind_rows(vwin_blue, vwin_orange)

```




```{r}
# ==============================================================
# 0  PACKAGES  --------------------------------------------------
library(dplyr)
library(tidyr)
library(afex)            # aov_4()
library(posterior)       # for Stan draws → data frame

# ==============================================================
# 1  HIGH- / LOW-SPQ GROUPS  -----------------------------------
n_group <- 22
spq_rank <- df_questionnaires |> arrange(desc(spq_z))

high_ids <- spq_rank$participant_id[1:n_group]
low_ids  <- spq_rank$participant_id[(nrow(spq_rank) - n_group + 1):nrow(spq_rank)]

df_groups <- df |>                        # df = full trial-level data
  filter(participant_id %in% c(high_ids, low_ids)) |>
  mutate(group = if_else(participant_id %in% high_ids, "HighSPQ", "LowSPQ"))

# ==============================================================
# 2 DEFINE THE TWO BLOCKS  ------------------------------------
blue_block <- df_groups |>
  filter(balloon_color == "b") |>
  group_by(participant_id) |>
  arrange(trial_number, .by_group = TRUE) |>
  slice_head(n = 30) |>
  ungroup()

orange_block <- df_groups |>
  filter(balloon_color == "o") |>
  group_by(participant_id) |>
  arrange(trial_number, .by_group = TRUE) |>
  slice_tail(n = 30) |>
  ungroup()

# ==============================================================
# 3  *STAN FITS ALREADY IN MEMORY*  -----------------------------
#    Rename below if your fits have different object names
fit_blue   <- blueblock_stanfit    # <-- change if needed
fit_orange <- orangeblock_stanfit  # <-- change if needed

get_vwin <- function(fit) {
  draws <- fit$draws(variables = "vwin", format = "draws_df") |>
           summarise(across(everything(), mean)) |>
           pivot_longer(everything(),
                        names_to  = "param",
                        values_to = "vwin") |>
           mutate(sub_idx = as.integer(sub("\\D+", "", param))) |>
           select(sub_idx, vwin)
  tibble(sub_idx = draws$sub_idx, vwin = draws$vwin)
}

# extract and bind
vwin_blue <- get_vwin(fit_blue)   |> mutate(block = "BlueBlock")
vwin_orng <- get_vwin(fit_orange) |> mutate(block = "OrangeBlock")

# participant-id mapping (order in Stan data = order of unique IDs in df_groups)
pid_lookup <- tibble(
  sub_idx        = seq_along(sort(unique(df_groups$participant_id))),
  participant_id = sort(unique(df_groups$participant_id))
)

vwin_tbl <- bind_rows(vwin_blue, vwin_orng) |>
  left_join(pid_lookup, by = "sub_idx") |>
  select(participant_id, vwin, block)

# create a subject-level table for median split (vwin is one value per person)
vwin_subject <- vwin_tbl |>
  group_by(participant_id) |>
  summarise(vwin = mean(vwin), .groups = "drop")

# ==============================================================
# 4  BEHAVIOURAL MEANS  ----------------------------------------
behaviour_tbl <- bind_rows(
  blue_block   |> group_by(participant_id) |> summarise(mean_infl = mean(inflations),
                                                        .groups = "drop") |> mutate(block = "BlueBlock"),
  orange_block |> group_by(participant_id) |> summarise(mean_infl = mean(inflations),
                                                        .groups = "drop") |> mutate(block = "OrangeBlock")
)

# ==============================================================
# 5  MERGE & RUN 2×2×2 ANOVA  ----------------------------------
analysis_df <- behaviour_tbl |>
  left_join(df_groups |> distinct(participant_id, group), by = "participant_id") |>
  left_join(vwin_subject, by = "participant_id") |>
  mutate(
    vwin_group = if_else(vwin <= median(vwin, na.rm = TRUE),
                         "LowVwin", "HighVwin"),
    across(c(group, vwin_group, block), as.factor)
  )

aov_blocks <- aov_4(mean_infl ~ group * vwin_group * block + (block | participant_id),
                    data = analysis_df, factorize = FALSE)

print(aov_blocks)

# (OPTIONAL) keep vwin continuous instead of splitting
# lmer_alt <- lme4::lmer(mean_infl ~ group * block + vwin + (1 + block | participant_id),
#                        data = analysis_df)
# summary(lmer_alt)

```
```{r}

library(dplyr)
library(tidyr)
library(afex)            # aov_4()
library(posterior)

n_group <- 22
spq_rank <- df_questionnaires |> arrange(desc(spq_z))

high_ids <- spq_rank$participant_id[1:n_group]
low_ids  <- spq_rank$participant_id[(nrow(spq_rank) - n_group + 1):nrow(spq_rank)]

df_groups <- df |>                      
  filter(participant_id %in% c(high_ids, low_ids)) |>
  mutate(group = if_else(participant_id %in% high_ids, "HighSPQ", "LowSPQ"))

get_vwin <- function(fit) {
  fit$draws("vwin", format = "draws_df") |>
    summarise(across(everything(), mean)) |>
    pivot_longer(everything(),
                 names_to  = NULL,
                 values_to = "vwin") |>
    mutate(sub_idx = row_number())
}

vwin_blue   <- get_vwin(fit_blue)
vwin_orange <- get_vwin(fit_orange)

pid_lookup <- tibble(
  sub_idx        = seq_along(sort(unique(df_groups$participant_id))),
  participant_id = sort(unique(df_groups$participant_id))
)

vwin_tbl <- vwin_blue |>
  rename(vwin_blue = vwin) |>
  left_join(vwin_orange |> rename(vwin_orange = vwin),
            by = "sub_idx") |>
  transmute(
    participant_id = pid_lookup$participant_id[sub_idx],
    vwin           = rowMeans(cbind(vwin_blue, vwin_orange), na.rm = TRUE)
  )

blue_block <- df_groups |>
  filter(balloon_color == "b") |>
  group_by(participant_id) |>
  arrange(trial_number, .by_group = TRUE) |>
  slice_head(n = 30) |>
  ungroup()

orange_block <- df_groups |>
  filter(balloon_color == "o") |>
  group_by(participant_id) |>
  arrange(trial_number, .by_group = TRUE) |>
  slice_tail(n = 30) |>
  ungroup()

behaviour_tbl <- bind_rows(
  blue_block   |> group_by(participant_id) |> summarise(mean_infl = mean(inflations),
                                                        .groups = "drop") |> mutate(block = "BlueBlock"),
  orange_block |> group_by(participant_id) |> summarise(mean_infl = mean(inflations),
                                                        .groups = "drop") |> mutate(block = "OrangeBlock")
)

# ==============================================================
# 4  MERGE & RUN ANCOVA  --------------------------------------
analysis_df <- behaviour_tbl |>
  left_join(df_groups |> distinct(participant_id, group), by = "participant_id") |>
  left_join(vwin_tbl, by = "participant_id") |>
  mutate(across(c(group, block), as.factor))

aov_blocks <- aov_4(mean_infl ~ group * block + vwin + (block | participant_id),
                    data        = analysis_df,
                    factorize   = FALSE)

print(aov_blocks)

# 3 way anova 
aov_3way <- aov_4(
  mean_infl ~ spq_z * vwin * block +            
    (block | participant_id),                  
  data      = analysis_df,
  factorize = FALSE                              
)

print(aov_3way)          


```


```{r cmdstan equivalent because of compiler issue or ARM}
cmd_stan_fit <- function(data, fit_name = "default") {
  model_path <- "stl_vec.stan"
  #output_path <- paste0("/media/ztefertiller/MRS_rsfMRI/zach_mcmc", fit_name, ".rds")
  output_path <- paste0("~/desktop", fit_name, ".rds")

  memory_used <- mem_change({
    mod <- cmdstan_model(model_path,  cpp_options = list(stan_threads = TRUE))
    
    fit <- mod$sample(
      data = data,
      iter_warmup = 1000,
      iter_sampling = 1000,
      chains = 4,
      parallel_chains = 4,
      threads_per_chain = 7,
      seed = 10191998,
      refresh = 500,  # adjusts console output
    )
  })

  print(memory_used)
  
  assign(fit_name, fit, envir = .GlobalEnv)
  saveRDS(fit, file = output_path)
  return(fit)
}




# file.copy(ewmv$output_files(),
#           to = "/media/ztefertiller/MRS_rsfMRI/zach_mcmc",
#           overwrite=TRUE
# )
```

```{r}
ewmv <- cmd_stan_fit(stan_data, "ewmv")
```

```{r}
variables <- fit$draws() %>% variables()

group_params <- grep("mu", variables, value=TRUE)

group_draws <- fit$draws(variables = group_params)

summary <- fit$summary()
print(summary)
```


```{r looic}
# loo diagnostic for one model
log_lik_array <- fit$draws(variables = "log_lik", format="array")
log_lik_array <- posterior::as_draws_array(log_lik_array)

dim_array <- dim(log_lik_array)

log_lik_matrix <- matrix(
  log_lik_array,
  nrow = dim_array[1] * dim_array[2],
  ncol = dim_array[3]
)

loo_result <- loo(log_lik_matrix)
print(loo_result)

k_vals <- pareto_k_values(loo_result)

library(ggplot2)

ggplot(data.frame(k = k_vals), aes(x = k)) +
  geom_histogram(bins = 50, fill = "skyblue", color = "black") +
  geom_vline(xintercept = 0.7, color = "red", linetype = "dashed") +
  labs(
    title = "Distribution of Pareto k Values",
    x = "Pareto k",
    y = "Count"
  ) +
  theme_minimal()

```





```{r}
#for copying stan csv files 
file.copy(fit$output_files(),
          to = "~/ztefertiller/bart_analyses/cmdstan_output/",
          overwrite=TRUE
)
```

```{r}
library(cmdstanr)
library(bayesplot)
library(loo)
library(posterior)

# assembling fit objects from csv data

folder_path <- "/media/ztefertiller/Transcend/mcmc/fourpar"
csv_files <- list.files(path = folder_path, pattern="\\.csv$", full.names =TRUE)
print(csv_files)
fourpar <- as_cmdstan_fit(csv_files)

folder_path <- "/Volumes/Transcend/mcmc/ewmv"
csv_files <- list.files(path = folder_path, pattern="\\.csv$", full.names =TRUE)
print(csv_files)
ewmv <- as_cmdstan_fit(csv_files)

folder_path <- "/media/ztefertiller/Transcend/mcmc/stl"
csv_files <- list.files(path = folder_path, pattern="\\.csv$", full.names =TRUE)
print(csv_files)
stl <- as_cmdstan_fit(csv_files)

folder_path <- "/Volumes/Transcend/mcmc/stl_color"
csv_files <- list.files(path = folder_path, pattern="\\.csv$", full.names =TRUE)
print(csv_files)
stl_color <- as_cmdstan_fit(csv_files)

folder_path <- "/Volumes/Transcend/mcmc/freemax"
csv_files <- list.files(path = folder_path, pattern="\\.csv$", full.names =TRUE)
print(csv_files)
freenmax <- as_cmdstan_fit(csv_files)
```


```{r looic}
# loo comparison between models 
library(loo)

log_lik_stl <- stl$draws("log_lik", format= "matrix")
log_lik_stl <- posterior::as_draws_array(log_lik_stl)

loo_stl <- loo(log_lik_stl)
print(loo_stl)

log_lik_ewmv <- ewmv$draws("log_lik", format= "matrix")
log_lik_ewmv <- posterior::as_draws_array(log_lik_ewmv)

loo_ewmv <- loo(log_lik_ewmv)
print(loo_ewmv)

log_lik_stl_color <- stl_color$draws("log_lik", format= "matrix")
log_lik_stl_color <- posterior::as_draws_array(log_lik_stl_color)

loo_stl_color <- loo(log_lik_stl_color)
print(loo_stl_color)

log_lik_4par <- fourpar$draws("log_lik", format= "matrix")
log_lik_4par <- posterior::as_draws_array(log_lik_4par)

loo_4par <- loo(log_lik_4par)
print(loo_4par)


loo_comparison <- loo_compare(
              loo_4par,
              loo_ewmv, 
              loo_stl,
              loo_stl_color
              )

loo_df <- as.data.frame(loo_comparison)
loo_df$elpd_diff <- as.numeric(loo_df$elpd_diff)
loo_df$elpd_diff <- -df$elpd_diff

ggplot(df, aes(x= reorder(model,elpd_diff), y=elpd_diff)) +
  geom_bar(stat= "identity", fill="steelblue") +
  geom_errorbar(aes(ymin = elpd_diff - se_diff, ymax = elpd_diff + se_diff), width =0.2) +
  coord_flip() +
  labs(
    x = "model",
    y = "relative predictive accuracy",
    title = "loo model comparison"
  ) +
  theme_minimal()

#subj level rhat avg
```









```{r}
library(posterior)
library(dplyr)
library(tidyr)

# Extract mean vwin per participant from already-run Stan fits
get_vwin_fixed <- function(fit, participant_ids, block_label) {
  vwin_draws <- fit$draws("vwin", format = "draws_matrix")  # [iterations × subjects]
  vwin_means <- colMeans(vwin_draws)

  tibble(
    participant_id = participant_ids,
    vwin           = as.numeric(vwin_means),
    block          = block_label
  )
}

# Get the participant order actually passed into the Stan model
ids_blue <- blue_block %>% distinct(participant_id) %>% arrange(participant_id) %>% pull()
ids_orange <- orange_block %>% distinct(participant_id) %>% arrange(participant_id) %>% pull()

# Extract vwin using correct mapping
vwin_blue <- get_vwin_fixed(fit_blue, ids_blue, "BlueBlock")
vwin_orange <- get_vwin_fixed(fit_orange, ids_orange, "OrangeBlock")

# Merge them
vwin_blocks <- bind_rows(vwin_blue, vwin_orange) %>%
  left_join(df_groups %>% distinct(participant_id, group), by = "participant_id") %>%
  mutate(across(c(group, block), as.factor))


library(afex)

aov_vwin <- aov_4(
  vwin ~ group * block + (block | participant_id),
  data = vwin_blocks,
  factorize = FALSE
)

print(aov_vwin)

```