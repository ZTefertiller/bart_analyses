# ---
# title:  "STL_model_fit"
# author: "Zach Tefertiller"
# date:   "2025-02-24"
# output: html_document
# zachary.tefertiller@tum.de
# ---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r load libraries and dataset}

library(dplyr)
library(bayesplot)
library(ggplot2)
library(rstan)
library(pryr)
library(loo)

# initial setup for my own task design, adapt balloon_color in the code and dataset as needed.

dataset <- read.csv('/Users/zachtefertiller/Desktop/BART RL 180 Data/balloon_task_clean_data.csv', header=TRUE, sep=",", stringsAsFactors=FALSE)

# setup dataframe for reversal
df <- dataset %>%
  mutate(color_max = case_when(
    balloon_color == 'y' ~ 32,
    balloon_color == 'o' & trial_number > 91 ~ 128,
    balloon_color == 'o' & trial_number < 91 ~ 8,
    balloon_color == 'b' & trial_number < 91 ~ 128,
    balloon_color == 'b' & trial_number >= 91 ~ 8
  ))

print_df_info <- function(df) {
  df_name <- deparse(substitute(df))
  number_of_participants <- length(unique(df$participant_id))
  number_of_trials <- nrow(df) / number_of_participants
  cat("Dataframe used:", df_name, "\n")
  cat("Number of trials per participant:", number_of_trials, "\n")
  cat("Number of participants with criteria:", number_of_participants, "\n")
  return(list(
    number_of_participants = number_of_participants,
    number_of_trials = number_of_trials
  ))
}

```


```{r summarize questionnaires if included}
# run this if you want to include spq, pdi, and caps in model

# dropping people who lack all questionnaires
df <- df %>%
  filter(!is.na(caps_total) & !is.na(pdi_total))


# summarize questionnaires, z-score, put in other dataframe for when we call
df_questionnaires <- df %>%
  group_by(participant_id) %>%
  summarise(
    spq_total  = first(spq_total_score),
    caps_total = first(caps_total),
    pdi_total  = first(pdi_total),
    pdi_distress  = first(pdi_distress),
    pdi_frequency  = first(pdi_frequency),
    pdi_conviction  = first(pdi_conviction),
    caps_distress = first(caps_distress),
    caps_frequency = first(caps_frequency),
    caps_intrusiveness = first(caps_intrusiveness),
    phq_total = first(phq_total),  
    mdq_total = first(mdq_total),
    ppgm_total = first(ppgm_total),
    ipip_total = first(ipip_total_score),
    
  ) %>%
  mutate(
    spq_z  = as.vector(scale(spq_total, center = TRUE, scale = TRUE)),
    caps_z = as.vector(scale(caps_total, center = TRUE, scale = TRUE)),
    pdi_z  = as.vector(scale(pdi_total, center = TRUE, scale = TRUE))
  )

df <- df %>% 
  left_join(df_questionnaires, by = "participant_id")

questionnaires <- df_questionnaires %>% 
  arrange(participant_id)

sub_ids <- unique(df$participant_id)


```


```{r different datasets per balloon color}
# separate data for when blue and orange are the high value balloon. yellow is constant
df_blue <- df %>% 
  filter(balloon_color == "b", color_max != 8) %>%
  arrange(participant_id, trial_number)

df_orange <- df %>% 
  filter(balloon_color == "o", color_max != 8) %>%
  arrange(participant_id, trial_number)

df_yellow <- df %>%
  filter(balloon_color == "y") %>%
  arrange(participant_id,trial_number)
```

```{SPQ Groups}

# quantiles <- quantile(df_blue$spq_total_score, probs = c(0.1, 0.9), na.rm = TRUE)

# bottom_cutoff <- quantiles[1]
# top_cutoff <- quantiles[2]

mean_spq <- mean(df_blue$spq_total_score, na.rm = TRUE)
sd_spq   <- sd(df_blue$spq_total_score, na.rm = TRUE)

bottom_cutoff <- mean_spq - .80 * sd_spq
top_cutoff    <- mean_spq + .80 * sd_spq


df_blue_high_spq <- df_blue %>%
 # filter(spq_total_score >= 10)
  filter(spq_total_score >= top_cutoff)

df_blue_low_spq <- df_blue %>%
 # filter(spq_total_score <= 10)
  filter(spq_total_score <= bottom_cutoff)

df_orange_high_spq <- df_orange %>%
 # filter(spq_total_score >= 10)
  filter(spq_total_score >= top_cutoff)

df_orange_low_spq <- df_orange %>%
 # filter(spq_total_score <= 10)
  filter(spq_total_score <= bottom_cutoff)

df_yellow_high_spq <- df_yellow %>%
 # filter(spq_total_score <= 10)
  filter(spq_total_score >= top_cutoff)

df_yellow_low_spq <- df_yellow %>%
 # filter(spq_total_score <= 10)
  filter(spq_total_score <= bottom_cutoff)


  
print(cat("high spq scorers:", length(unique(df_blue_high_spq$participant_id)), "\n"))
print(cat("sanity check # of trials per person: ",
((nrow(df_blue_high_spq))/(length(unique(df_blue_high_spq$participant_id))))))

print(cat("low spq scorers:", length(unique(df_blue_low_spq$participant_id)), "\n"))
print(cat("sanity check # of trials per person: ", ((nrow(df_blue_low_spq))/(length(unique(df_blue_low_spq$participant_id))))))

```

```{CAPS Groups}

quantiles <- quantile(df_blue$caps_total, probs = c(0.1, 0.9), na.rm = TRUE)

bottom_cutoff <- quantiles[1]
top_cutoff <- quantiles[2]

mean_caps <- mean(df_blue$caps_total, na.rm = TRUE)
sd_spq   <- sd(df_blue$caps_total, na.rm = TRUE)

# bottom_cutoff <- mean_caps - 1 * sd_caps
# top_cutoff    <- mean_caps + 1 * sd_caps


df_blue_high_caps <- df_blue %>%
 # filter(caps_total_score >= 10)
  filter(caps_total_score >= top_cutoff)

df_blue_low_caps <- df_blue %>%
 # filter(caps_total_score <= 10)
  filter(caps_total_score <= bottom_cutoff)

df_orange_high_caps <- df_orange %>%
 # filter(caps_total_score >= 10)
  filter(caps_total_score >= top_cutoff)

df_orange_low_caps <- df_orange %>%
 # filter(caps_total_score <= 10)
  filter(caps_total_score <= bottom_cutoff)

df_yellow_high_caps <- df_yellow %>%
 # filter(caps_total_score <= 10)
  filter(caps_total_score >= top_cutoff)

df_yellow_low_caps <- df_yellow %>%
 # filter(caps_total_score <= 10)
  filter(caps_total_score <= bottom_cutoff)


  
print(cat("high caps scorers:", length(unique(df_blue_high_caps$participant_id)), "\n"))
print(cat("sanity check # of trials per person: ",
((nrow(df_blue_high_caps))/(length(unique(df_blue_high_caps$participant_id))))))

print(cat("low caps scorers:", length(unique(df_blue_low_caps$participant_id)), "\n"))
print(cat("sanity check # of trials per person: ", ((nrow(df_blue_low_caps))/(length(unique(df_blue_low_caps$participant_id))))))

```


```{r load function: stan input data}
# function for assembling the data for STAN model
# questionnaires excluded as model params by default

create_stl_stan_params <- function(df, include_questionnaires = FALSE) {
  nsub <- length(unique(df$participant_id))
  ntrial <- nrow(df) / nsub
  outcome   <- matrix(df$popped, nrow = nsub, ncol = ntrial, byrow = TRUE)
  npumps    <- matrix(df$inflations, nrow = nsub, ncol = ntrial, byrow = TRUE)
  nmax <- matrix(df$optimal_inflations, nrow = nsub, ncol = ntrial, byrow = TRUE)
  opportunity <- npumps + (1 - outcome)
  maxpump <- max(nmax)
  
  # map balloon color to numbers for stan
  # blue = 1
  # orange = 2
  # yellow = 3
  df$balloon_color_num <- match(df$balloon_color, c("b", "o", "y"))
  balloon_color <- matrix(df$balloon_color_num, nrow = nsub, ncol = ntrial, byrow = TRUE)
  
  d <- array(75, dim = c(nsub, ntrial, maxpump))
  for (i in 1:nsub) {
    for (j in 1:ntrial) {
      pumps <- npumps[i, j]
      out   <- outcome[i, j]
      if (pumps > 0) {
        d[i, j, 1:pumps] <- rep(1, pumps)
      }
      if (pumps < maxpump && out == 0) {
        d[i, j, pumps + 1] <- 0
      }
    }
  }
  
  stan_data <- list(
    nsub = nsub,
    ntrial = ntrial,
    outcome = outcome,
    npumps = npumps,
    nmax = nmax,
    opportunity = opportunity,
    maxpump = maxpump,
    d = d,
    balloon_color = balloon_color,
    sub_ids = sub_ids  # including participant ids for tracking in stan summary
  )

  if (include_questionnaires) {
      questionnaires <- data.frame(
        participant_id = df$participant_id[!duplicated(df$participant_id)],
        spq_z = df$spq_z[!duplicated(df$participant_id)],
        caps_z = df$caps_z[!duplicated(df$participant_id)],
        pdi_z = df$pdi_z[!duplicated(df$participant_id)]
      )
      stan_data$spq  <- questionnaires$spq_z    # spq paired w/ participant_ids
      stan_data$caps <- questionnaires$caps_z   # caps 
      stan_data$pdi  <- questionnaires$pdi_z    # pdi
  }
  
  return(stan_data)
}
```


```{r loading stan parameters}
stl_stan_data <- create_stl_stan_params(df)
```


```{r load function: fit model}
# run the model and provide a string for fit_name for the environment and saving to desktop
run_stan_fit <- function(data, fit_name = "default") {
  # uncomment line below and sample_file in the sampling function call to save CSV files per chain 
  #sample_file <- paste0("/Users/zachtefertiller/Desktop/", "mcmc", fit_name)
  memory_used <- mem_change({
    mod <- stan_model(file
        ="/Users/zachtefertiller/Desktop/bart_analyses/modeling/STL_HBM_color.stan")
    fit <- sampling(
      mod,
      data = data,          # stan data
      iter = 500,          # iterations total
      warmup = 500,        # how many burn in out of total
      save_warmup = TRUE,
      chains = 4,           # number of chains
      seed = 10191998,      # (it is my birthday in MM-DD-YYYY btw)
      # sample_file = sample_file,  # uncomment for csv file saving
      cores = 6             # parallel chains (overloads system memory if too many)
    )
  })
  print(memory_used)
  assign(fit_name, fit, envir = .GlobalEnv)
  saveRDS(fit, file = paste0("/Users/zachtefertiller/Desktop/", fit_name, ".rds"))
  return(fit)
}
```


```{r load function: extract draws}
get_draws <- function(fit, include_questionnaires = FALSE, extra_parameters = NULL) {
  if (include_questionnaires) {
    group_factors <- c("mu_vwin", "mu_vloss", "mu_omegaone",
                       "mu_beta", "beta_vwin_spq", "beta_vloss_spq",
                       "beta_beta_spq", "beta_omegaone_spq", "beta_vwin_caps",
                       "beta_vloss_caps", "beta_beta_caps", "beta_omegaone_caps",
                       "beta_vwin_pdi", "beta_vloss_pdi", "beta_omegaone_pdi",
                       "beta_beta_pdi")
  } 
  else {
    group_factors <- c("mu_vwin", "mu_vloss", "mu_omegaone",
                       "mu_beta", "vwin", "vloss", "beta", "omegaone")
  }
  
  if (!is.null(extra_parameters)) {
    group_factors <- c(group_factors, extra_parameters)
  }
  
  #draws_array <- as.array(fit, pars = group_factors, inc_warmup = TRUE)
  draws_array <- rstan::extract(fit, permuted = FALSE, inc_warmup = TRUE)
  print(draws_array)
  return(draws_array)
}
```


# summarize_stanfit()
```{r load function: get stanfit summary}
# function to get summary stats for the model
summarize_stanfit <- function(fit, questions = NULL, include_loo = TRUE) {
  base_pars <- c("mu_vwin", "mu_vloss", "mu_omegaone", "mu_beta", "vwin", "vloss", "omegaone", "beta")
  
  # in case you add questionnaires as a parameter ie a regressor in the model to extract
  if (!is.null(questions)) {
    beta_pars <- unlist(lapply(questions, function(q) {
      paste0("beta_", c("vwin", "vloss", "omegaone", "beta"), "_", q)
    }))
    pars <- c(base_pars, beta_pars)
  } else {
    pars <- base_pars
  }
  params_summary <- summary(fit, pars = pars)$summary
  print(params_summary)

}

```


# param_extract()
```{r load function: make array for estimated parameters from stanfit summary}
param_extract <- function(fit, sub_ids,
                          pars = c("vwin","vloss","beta","omegaone")) {
  sum_mat <- summary(fit, pars = pars)$summary
  extract_stats <- function(param_name) {
    rows   <- grep(paste0("^", param_name, "\\["), rownames(sum_mat))
    means  <- sum_mat[rows, "mean"]
    rhats  <- sum_mat[rows, "Rhat"]
    list(mean = means, Rhat = rhats)
  }
  stats_list <- lapply(pars, extract_stats)
  names(stats_list) <- pars
  df <- data.frame(participant_id = sub_ids, stringsAsFactors = FALSE)
  for (p in pars) {
    df[[paste0(p)]] <- stats_list[[p]]$mean
    df[[paste0(p, "_Rhat")]] <- stats_list[[p]]$Rhat
  }
  
  return(df)
}
```


```{r}
blue_sum <- summarize_stanfit(blue_stl_all)
blue_params <- param_extract(blue_stl_all, stan_data_blue$sub_ids)
blue_merge <- left_join(df_blue, blue_params, by = "participant_id")
blue_merge$opportunity <- with(blue_merge, inflations + (1 - popped))
```
